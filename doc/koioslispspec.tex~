%Partial application?
%%%% USE XETEX
\documentclass[10pt]{book}
\usepackage{longtable}
\usepackage{fullpage}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{sectsty}
\usepackage{fontspec}
\usepackage{ textcomp }
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\setmonofont[Scale=0.8]{Monaco}
\setsansfont{TeXGyreHeros}
\allsectionsfont{\sffamily}
\newenvironment{defother}[2]{[\textit{#1}]\\\texttt{#2}}{\\}
\newenvironment{defun}[1]{\begin{defother}{Function}{#1}}{\end{defother}}
\newenvironment{defgeneric}[1]{\begin{defother}{Generic Function}{#1}}{\end{defother}}
\newenvironment{defmethod}[1]{\begin{defother}{Method}{#1}}{\end{defother}}
\newenvironment{defmacro}[1]{\begin{defother}{Macro}{#1}}{\end{defother}}
\newenvironment{special-form}[1]{\begin{defother}{Special form}{#1}}{\end{defother}}
\newenvironment{defvar}[1]{\begin{defother}{Variable}{#1}}{\end{defother}}
\newenvironment{defconstant}[1]{\begin{defother}{Constant}{#1}}{\end{defother}}
\newenvironment{defclass}[2]{[\textit{Class}]\\\texttt{#1}\\\textit{Superclasses:} \texttt{#2}\\\textit{Slots:}}{\\}
\newenvironment{condition}[1]{\begin{defother}{Condition}{#1}}{\end{defother}}
\newenvironment{named-restart}[1]{\begin{defother}{Named restart}{#1}}{\end{defother}}
\newenvironment{lisp}{\begin{ttfamily}\begin{tabbing}}{\par\end{tabbing}\end{ttfamily}}
\newcommand{\tab}{\hspace*{2em}}
\author{Yash Tulsyan}
%%Note to self: possibly deprecate regular expressions and promote use of SNOBOL-esque pattern-matching tools for all string-manipulation tasks. This deserves further research.
%%%%Make SURE to note that tail-call optimization is MANDATORY
%%%% For easy porting of CL: create a CL package, an alias macro, etc. 
%%%% Make a MATH package that ships with KL but is not used by default

\title{The Koioslisp Specification and Notes, version 0.0}
\begin{document}
\maketitle
\tableofcontents
\chapter{Preface}
\chapter{Acknowledgements}
If Koioslisp is a better language than others (a questionable proposition), it is, proverbially, because it stood on the shoulders of giants. First and foremost, I must acknowledge all the Lispers who came before me--the hackers of MIT, BBN, Xerox, the Lisp Machine world, and the Lisp community of today--for without their work, none of this would be possible. In particular, I must acknowledge the great implementors and theorists--giants of the LISP community: Professor John McCarthy, Steve Russell, Jonl White, Guy L. Steele, David Moon, Richard P. Gabriel, Richard M. Stallman, Gerald Jay Sussman, and more. I must also acknowledge the giants of recent times such as Paul Graham, Peter Seibel, Pascal Costanza, Edi Weitz, Zach Beane, Fran\c{c}ois-Ren\'{e} Rideau, James Kalenius, Nikodemus Siivola, Shriram Krishnamurthi, Stanislav Datskovskiy and Rich Hickey.
\chapter{Inspiration and Design Features}
Primary inspiration for {\sc Koioslisp} came from the {\sc Common Lisp} programming language (indeed, the document you are reading right now is structured based on the authoritative {\sc Common Lisp} reference, \textit{Common Lisp, the Language} by Guy L. Steele), with influences from {\sc Scheme}, {\sc Clojure}, and {\sc Prolog} A design influence comes from the language {\sc Python} and other modern scripting languages--in that ``batteries'' (i.e. utilities to connect to the rest of the world) should come included in the standard library, which is indeed part of the reason features which seem superfluous are included in {\sc Koioslisp}. In the specification, batteries will be marked clearly, as such utilities are far more likely to change over time. {\sc Koioslisp} attempts to unify the strengths of these Lisp dialects into one--{\sc Common Lisp} for its completeness, macros, object system, historical significance,large amounts of libraries (hopefully, the amount of compatibility given by {\sc Koioslisp} will encourage people to port useful libraries to it, such as ASDF, or SWANK(which is used for SLIME, the free Lisp IDE on Emacs)), and continuity; {\sc Scheme} for its elegance, continuations, and assorted innovations; {\sc Clojure} for its concurrency support, clean hash tables, and lazy evaluation.It also features {\sc Prolog}-style logic programming. In doing so, it tries to avoid the problems of the languages above mentioned. While {\sc Common Lisp} and {\sc Scheme} have aged relatively well, {\sc Common Lisp} has non-lispy hash tables and some marks of age, while {\sc Scheme}, though good for pedagogy, is crippled by its size and lack of powerful macros (though it does have ``hygenic'' macros), as well as some marks of age. Meanwhile, {\sc Clojure} is dependent on the JVM (or, in the case of its new ports, the CLR and JavaScript--which create some incompatibility between implementations, as {\sc Clojure} feeds off of those engines and absorbs their libraries and object systems), also has nearly-unusable macros, and \textit{gratuitously} incompatible with {\sc Common Lisp}, a dialect meant to end such incompatibilities. (as {\sc Scheme} came before {\sc Common Lisp} and was designed for pedagogy and to test the Actor model, it is excused from this criticism), and {\sc Prolog} is entirely unusable for programming-in-the-large, being useful mainly as an extension to Lisp. Throughout this document, some compatibility notes will be recorded.
\chapter{Introduction}
This is a specification for a {\sc Koioslisp}, a {\sc Lisp} dialect, which will evolve as time goes on and the fickle attitudes of the BDFL, Yash Tulsyan, change. If you are a programmer from C-like languages who expects a C-like syntax and a C++ (or Java/C\#) like object-oriented system imposed upon the user, then please either accept that this will not cater to that palate, or leave. If you are a programmer from Haskell or ML-like languages who is similarly put-off by s-expressions, want a functional style to be imposed upon the user, and caution against side-effects, we advise a similar course of action. As of this moment, this specification does not come with any standard implementation, due to the fact that the BDFL is currently a simple student who has not yet learned how to create a fully-featured compiler or an interpreter.
\section{Do We Really Need Another Dialect?}
This question appears whenever a new language appears, and in Lisp it is especially important, due to both its history and {\sc Common Lisp} macros. My answer to this: Maybe. If so, this is going to be it. If not, we (or at least, I) will probably use Common Lisp.
\section{Design Goals of Koioslisp}
\subsection{Extensibility}
\subsection{Power}
\subsection{Consistency}
\subsection{Ease of use}
\section{Naming Conventions}
%%Change these from subsections to something else.
None of these are enforced, but they are followed consistently, for the most part, internally--and describe naming conventions dominant in the LISP world.
\subsection{multi-word-symbol}
In programing, there have beem several conventions with creating identifiers with multiple words--such as C\textunderscore style\textunderscore identifiers, or CamelCase. As a member of the LISP family of languages, {\sc Koioslisp} uses the Lisp convention of putting hyphens between words.
\subsection{predicatep}
This convention designates that \textit{predicates}--functions that test whether or not a given proposition is true (such as \texttt{typep})--should have names that end with either a 'p' or a '-p'.
%% 'P' and '-P' convention here
\subsection{n-destructive-function}
This convention designates that \textit{destructive functions}, which modify one or more of their arguments, should be prefixed with an 'n' or an 'n-'.
%% 'N' and 'N-' convention here
\subsection{*dynamic-variable*}
\textit{Dynamic}, or \textit{global variables} should be surrounded by asterisks.
\subsection{+constant-variable+}
Note that this is generally not consistently used internally--for example, the constants T, NIL, and PI are not surrounded by plus signs, due to convention. Otherwise, constants are marked by being surrounded with plus signs.
\subsection{variant*}
Usually, when one is defining  a function which is only slightly different in behavior to a better-known pre-existing function, one appends an asterisk to it.
\subsection{$<$class$>$}
This convention, however, does \textit{not} apply to class wrappers around built-in {\sc Koioslisp} types.
\subsection{with-dynamic-context}
\subsection{deffoo}
\subsection{make-foo}
\section{Conventions Used in This Book}
\chapter{Data Types}
\section{Class Hierarchy of Koioslisp}

\section{Numbers}
As in most programming languages, there are several different types of numbers in {\sc Koioslisp}, and, as in Common Lisp, they are divided into four main categories: \textit{integers}, \textit{ratios}, \textit{floating-point numbers}, and \textit{complex numbers}. Integers and ratios are contained by the type \textit{rational}. Rational numbers and floating-point numbers are of the type \textit{real}, and finally real numbers and complex numbers are of type \textit{number}.
\subsection{Integers}
Integers function as in Common Lisp--as representations of mathematical integers. There are no standard restrictions on the magnitude of an integer, as storage should be automatically allocated for representing large integers. However, there might still be a low-level distinction between very efficient integers of smaller magnitude (\texttt{fixnums}) and larger integers, called \texttt{bignums}. Though this distinction may exist in implementations of the language, Koioslisp is designed, like Common Lisp, to hide the distinction whenever possible. Because the numbers which may be considered fixnums and those which may be considered bignums will vary from implementation to implementation, the constants \texttt{+most-positive-fixnum+} and \texttt{+most-negative-fixnum+} are provided.%% Provide fiddly type details here
%%MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM should not be constants, but functions
As in most programming languages, integers are canonically written as they are canonically in arithmetic--with decimal digits, possibly preceded by a sign and followed by a decimal point. Integers can be written in bases other than the default 10. The syntax \texttt{\#\textit{nn}r\textit{ddddd}}, case insensitively, will refer to the integer represented in \textit{nn}-radix by \textit{ddddd}, where \textit{nn} is between 2 and 36, inclusive, and \textit{ddddd} is an integer. When representing numbers in radices above 10, use of letters to represent numbers is case-insensitive--that is, \texttt{\#16rFACADE} is the same as \texttt{\#16RfacaDE}. Binary, octal, and hexadecimal are relatively common, and so they are granted the abbreviations \texttt{\#b}, \texttt{\#o} and \texttt{\#x}.
%%Examples
\subsection{Ratios}
A \textit{ratio} is, as in \textsc{Common Lisp}, a representation of a mathematical ratio, and the other part (along with integers) that constitute the type \texttt{rational}. The canonical representation of a ratio is either an integer if it is equal to an integer, or the ratio of a \textit{numerator} and \textit{denominator}, which are both integers, and whose greatest common denominator is one. The character \texttt{\textbackslash} separates the numerator from the denominator. One can input a non-canonical value, but a ratio will always be printed by \texttt{print} in its canonical form. As all other reals, ratios may be signed, (with the same syntax as other real numbers). Internally, ratios in non-canonical form will be converted to canonical form. The denominator of a ratio must not be zero; if it is zero, an error is signaled. As with integers, ratios can be used in different radices, with the same syntax.
%%Examples
\subsection{Floating Point Numbers}
\subsection{Complex Numbers}
\section{Characters}
\subsection{Standard Characters}
Koioslisp uses a standard character set in order to enhance portability--Koioslisp programs that use only the standard set of characters can be (assuming no other implementation-specific (mis)features are used) read by any Koioslisp implementation.
The standard character set of {\sc Koioslisp} is nearly identical to the Unicode character set. As the Unicode character set has several thousands of characters, it will not be displayed here. It also includes ways to denote non-printing characters, such as \begin{verbatim}#\newline #\space #\backspace #\tab #\linefeed #\page #\return \end{verbatim}. Of the non-blank printing characters, most are not used in {\sc Koioslisp} syntax. For brevity, we shall note the subset of  the subset of the Unix code subset ``Basic Latin'' which denotes punctuation which is not commonly used in {\sc  Koioslisp} syntax: [ ] \{ \} !  \textasciicircum \textunderscore \textasciitilde \$ \%. Almost all of these, however, are used as format directives. Other than that, the following characters are explicitly reserved for the user's syntactic extenstion purposes: [, ], \{, \}, \$, \%, !, . This preserves the syntactic purity and clarity of Lisp, unlike some recent dialects which insist on the introduction of other forms of brackets, allegedly for purposes of clarity.  See chapter ``Input/Output'' for greater detail on transforming constituent characters into macro characters %% ? *may* be necessary for pattern-matching; look this up
\subsection{Line Divisions}
Unlike the nightmare of implementing a standard method of line division in previous decades, the structure of line divisions has simplified from a variety of schemas involving linefeeds, carriage returns, and other such characters into two schemes--either a bare linefeed (LF) character, used by {\sc Unix} and its descendants; or a linefeed following a carriage return (CR), used by MS-DOS and Microsoft Windows. Like Common Lisp and C, {\sc Koioslisp} uses the abstract requirement of requiring a single character, \begin{verbatim}#\newline\end{verbatim} to act as a delimiter between lines. This character may be externally translated to whatever sort of line-division schema the underlying operating system uses, however, it must internally use one character, and one character only. Another issue is raised. Suppose one types the following: \begin{verbatim} #\Return#\Newline\end{verbatim}. Implementations should not suppress the call to \begin{verbatim}#\Return\end{verbatim}, for there are certain standards (such as the Internet Relay Chat (IRC) protocol) which require CRLF sequences.  
\subsection{Non-standard Characters}
{\sc Koioslisp} implementations may add extra characters, however, this may render programs using such characters unportable.
\subsection{Character Attributes}

\section{Symbols}
\section{Arrays}

\section{Vectors}
\section{Strings}
\section{Bit-Vectors}
\section{Hash Tables}
\section{Readtables}
\section{Packages}
\section{Pathnames}
\section{Sockets}
\section{Streams}
\section{Random-States}
\section{Structures}
\section{Functions}
\section{Objects}
\section{Continuations}
{\sc Koioslisp}, like Scheme, provides \textit{continuations}, convenient and abstract mechanisms for controlling the control state of a program. Unlike Scheme, however, these are \textit{delimited} continuations. Though they can be discussed here as structures, due to their nature as GOTO-like mechanisms (though theoretically much more fundamental), they are discussed in greater detail in the Continuations chapter of this book.
\section{Laziness and Lazy Types}
Though \textit{lazy evaluation} refers to an evaluation strategy, it is useful to speak of \textit{lazy} forms of data structures, of which the most central is the lazy list. 
\section{Unreadable Data Objects}
\section{Overlap, Inclusion, and Disjointness of Types}
\chapter{Scope and Extent}
\textit{Scope} and \textit{extent} are important when discussing features of a language. \textit{Scope} is the spatial region on which a variable is defined--\textit{extent} is the temporal region. Koioslisp, like Common Lisp, utilizes two systems of scope and two systems of extent--\textit{lexical scope}, \textit{indefinite scope}, \textit{dynamic extent}, and \textit{indefinite extent}.
\chapter{Type Specifiers}
\chapter{Program Structure}
\chapter{Predicates}
\begin{defun}{eq?}\end{defun}
\begin{defun}{eqv?}\end{defun}
\begin{defgeneric}{=?}\end{defgeneric} %With alias equal? 
\begin{defun}{not} \textit{x}\end{defun}
\begin{defmacro}{and} \&rest \textit{forms}\end{defmacro}
\begin{defmacro}{or} \&rest \textit{forms}\end{defmacro}
\begin{defun}{xor} \&rest \textit{forms}\end{defun}
\begin{defun}{type?} \textit{object type}\end{defun} %With alias class?
\chapter{Control Structure}
\begin{defmacro}{zap!}\end{defmacro} %The arc definition
\begin{defmacro}{alias}\end{defmacro} %Does it have to be in a macro? 
\begin{defmacro}{partial} \textit{function args-or-placeholders}\\
A \textit{placeholder} is represented the atom \texttt{_} and the placeholder arguments form the arguments of the returned function\end{defun}
\begin{defun}{memoize}\end{defun}
\begin{defun}{compose} \textit{f} \&rest \textit{funs} \end{defun}
\begin{defun}{conjoin} \&rest \textit{predicates}\end{defun}
\begin{defun}{disjoin} \&rest \textit{predicates}\end{defun}
\section{Constants and Variables}
\subsection{Reference}
\subsection{Assignment and Bindings}
\subsubsection{Low-Level Assignment}
Like TAGBODY, PROG and GO, many of these functions are not used often in casual code, but they are necessary in the implementation of some of the higher-level functions and indispensible in the implementation of new languages upon Koios. 
\begin{defun}{\%set}\end{defun}%CL::SET
\begin{defun}{\%setq}\end{defun}
\subsubsection{Generalized References}
\begin{defmacro}{set!}\end{defmacro}%CL::SETF
\begin{defmacro}{pset!}\end{defmacro}
\begin{defmacro}{rotate!}\end{defmacro}
\begin{defmacro}{shift!}\end{defmacro}
\begin{defmacro}{defzap}\end{defmacro}%CL::DEFINE-MODIFY-MACRO
\begin{defmacro}{defsetter}\end{defmacro}%CL::DEFSETF
\begin{defmacro}{defsetter*}\end{defmacro}%CL::DEFINE-SETF-METHOD
\subsubsection{Establishing New Bindings}
\begin{special-form}{let} (\{\textit{var} | (\textit{var value})\}*) \{\textit{declaration}\}* \{\textit{form}\}*\\
A \texttt{let} form introduces new variable bindings to be used in the forms it contains.\\

Unlike previous lisps (except Clojure), in Koioslisp, \texttt{let} supports \textit{destructuring}, of the sort found in the \texttt{destructuring-bind} construct in \textsc{Common Lisp}. It also supports the functionality previously in the \textsc{Common Lisp} construct \texttt{multiple-value-bind}. See also the Koioslisp constraint-programming facilities.
\end{special-form}
\section{Sequencing}
\begin{special-form}{begin} \{\textit{form}\}*\end{special-form} %CL::PROGN
\begin{special-form}{\%progx} \textit{integer} \{\textit{form}\}*\end{special-form}
\section{Iteration}
\begin{defmacro}{do} (\{\textit{var} | (\textit{var} [\textit{init} [\textit{step}]])\}*) (\textit{end-test} \{\textit{result}\}*) \{\textit{declaration}\}* \{\textit{tag} | \textit{statement}\}*\\
\texttt{do} is a very powerful, useful, and arcane (at least, to newcomers) macro meant to facilitate complex iterations.
\end{defmacro}
\begin{defmacro}{do*}(\{\textit{var} | (\textit{var} [\textit{init} [\textit{step}]])\}*) (\textit{end-test} \{\textit{result}\}*) \{\textit{declaration}\}* \{\textit{tag} | \textit{statement}\}*\\
As the name suggests, \texttt{do*} is a variant of \texttt{do}
\end{defmacro}
\begin{defmacro}{doseq} (\textit{var} \textit{listform} [\textit{resultform}]) \{\textit{declaration}\}* \{\textit{tag} | \textit{expression}\}*\\ \texttt{doseq} \end{defmacro}
\begin{defmacro}{dotimes} (\textit{var} \textit{listform} [\textit{countform}]) \{\textit{declaration}\}* \{\textit{tag} | \textit{expression}\}*\\ \texttt{dotimes}\end{defmacro}
\subsection{Low-Level Iteration}
Like \%SET and \%SETQ, many of these functions are not used often in casual code, but they are necessary in the implementation of some of the higher-level functions and indispensible in the implementation of new languages upon Koios.\\
\begin{special-form}{\%tagbody} \{\textit{tag} | \textit{expression}\}*\end{special-form}
\begin{special-form}{\%go} \textit{tag}\end{special-form}

\begin{defmacro}{\%prog} ( \{\textit{var} | (\textit{var} [\textit{init}])\}*) \{\textit{declaration}\}* \{\textit{tag} | \textit{expression}\}*\end{defmacro}
\begin{defmacro}{\%prog*} ( \{\textit{var} | (\textit{var} [\textit{init}])\}*) \{\textit{declaration}\}* \{\textit{tag} | \textit{expression}\}*\end{defmacro}
\subsection{LOOP}
The syntax and semantics of the LOOP macro in Koioslisp is very different than that of Common Lisp, which has been criticized for being inelegant, inextensible, and generally un-Lispy; though regarded as an excellent demonstration of Lisp's ability to create domain-specific languages. Instead, it is based upon the related ITERATE library for Common Lisp.\\
\begin{defmacro}{loop}\end{defmacro}
\begin{defother}{Loop clause}{repeat} \textit{n} \end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \&sequence\\
\&sequence is one of the following symbols: \texttt{:from}, \texttt{:upfrom}, \texttt{:downfrom}, \texttt{:to}, \texttt{:downto}, \texttt{:above}, \texttt{:below}, and \texttt{:by}.\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:in} \textit{sequence} \&sequence\end{defother}
\begin{defother}{Loop clause}{for} \textit{key val} \texttt{:in-table} \textit{table} \end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:in-package} \textit{package} \&optional \texttt{:external-only} \textit{external-only?}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:in-packages} \textit{package} \&optional \texttt{:having-access} \textit{symbol-types}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:in-file} \textit{filename} \&optional \texttt{:using} \textit{reader}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:in-stream} \textit{stream} \&optional \texttt{:using} \textit{reader}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:next} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:do-next} \textit{form}\end{defother}
\begin{defother}{Loop clause}{for} \textit{pvar} \texttt{:previous} \textit{var} \&optional \texttt{:initially} \textit{init} \texttt{:back} \textit{n}\end{defother}
%
\begin{defother}{Loop clause}{with} \textit{var} \&optional \texttt{:=} \textit{value}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:=} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:initially} \textit{init-expr} \texttt{:then} \textit{then-expr}\end{defother}
\begin{defother}{Loop clause}{for} \textit{var} \texttt{:first} \textit{first-expr} \texttt{:then} \textit{then-expr}\end{defother} %Yes, this differs from :initially
\begin{defother}{Loop clause}{sum} \textit{expr} \&optional \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{multiply} \textit{expr} \&optional \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{counting} \textit{expr} \&optional \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{maximize} \textit{expr} \&optional \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{reducing} \textit{expr} \texttt{:by} \textit{func} \&optional \texttt{:initial-value} \textit{init-val} \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{collecting} \textit{exptr} \&optional \texttt{:into} \textit{var} \texttt{:at} \textit{place} \texttt{:result-type} \textit{type}\\ \textit{place} is one of \texttt{:start}, \texttt{:beginning} (a synonym for \texttt{:start}) or \texttt{:end}.\end{defother}
\begin{defother}{Loop clause}{adjoining} \textit{exptr} \&optional \texttt{:into} \textit{var} \texttt{:at} \textit{place} \texttt{:result-type} \textit{type}\\ \textit{place} is one of \texttt{:start}, \texttt{:beginning} (a synonym for \texttt{:start}) or \texttt{:end}.\end{defother}
\begin{defother}{Loop clause}{appending} \textit{exptr} \&optional \texttt{:into} \textit{var} \texttt{:at} \textit{place} \texttt{:result-type} \textit{type}\\ \textit{place} is one of \texttt{:start}, \texttt{:beginning} (a synonym for \texttt{:start}) or \texttt{:end}.\end{defother}
\begin{defother}{Loop clause}{appending!} \textit{exptr} \&optional \texttt{:into} \textit{var} \texttt{:at} \textit{place} \texttt{:result-type} \textit{type}\\ \textit{place} is one of \texttt{:start}, \texttt{:beginning} (a synonym for \texttt{:start}) or \texttt{:end}.\end{defother}
\begin{defother}{Loop clause}{unioning} \textit{exptr} \&optional \texttt{:into} \textit{var} \texttt{:at} \textit{place} \texttt{:result-type} \textit{type}\\ \textit{place} is one of \texttt{:start}, \texttt{:beginning} (a synonym for \texttt{:start}) or \texttt{:end}.\end{defother}
\begin{defother}{Loop clause}{unioning!} \textit{exptr} \&optional \texttt{:into} \textit{var} \texttt{:at} \textit{place} \texttt{:result-type} \textit{type}\\ \textit{place} is one of \texttt{:start}, \texttt{:beginning} (a synonym for \texttt{:start}) or \texttt{:end}.\end{defother}
\begin{defother}{Loop clause}{accumulate} \textit{expr} \texttt{:by} \textit{func} \&optional \texttt{:initial-value} \textit{init-val} \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{finding} \textit{expr} \texttt{:such-that} \textit{test} \&optional \texttt{:into} \textit{var} \texttt{:on-failure} \textit{failure-value}\end{defother}
\begin{defother}{Loop clause}{finding} \textit{expr} \texttt{:maximizing} \textit{m-expr} \&optional \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{finding} \textit{expr} \texttt{:minimizing} \textit{m-expr} \&optional \texttt{:into} \textit{var}\end{defother}
\begin{defother}{Loop clause}{first-iteration?}\end{defother}
\begin{defother}{Loop clause}{first-time?}\end{defother}
\begin{defother}{Loop clause}{always} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{never} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{there-is} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{finish}\end{defother}
\begin{defother}{Loop clause}{leave} \&optional \textit{value}\end{defother}
\begin{defother}{Loop clause}{next-iteration}\end{defother}
\begin{defother}{Loop clause}{while} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{until} \textit{expr}\end{defother}
\begin{defother}{Loop clause}{if-first-time} \textit{then} \&optional \textit{else}\end{defother}
\begin{defother}{Loop clause}{initially} \&rest \textit{forms}\end{defother}
\begin{defother}{Loop clause}{after-each} \&rest \textit{forms}\end{defother}
\begin{defother}{Loop clause}{else} \&rest \textit{forms}\end{defother}
\begin{defother}{Loop clause}{finally} \&rest \textit{forms}\end{defother}
\begin{defother}{Loop clause}{finally-protected} \&rest \textit{forms}\end{defother}
\begin{defother}{Loop clause}{in} \textit{name} \&rest \textit{forms}\end{defother}
\begin{defun}{display-loop-clauses} \&optional \textit{clause-spec}\end{defun}
\begin{defmacro}{defloop} \textit{arglist} \&body \textit{body} \end{defmacro}
\begin{defmacro}{defloop-driver} \textit{arglist} \&body \textit{body}\end{defmacro}
\begin{defmacro}{defloop-alias} \textit{syn word}\end{defmacro}
\begin{defmacro}{defloop-sequence} \textit{element-name index-name} \&key \textit{access-fn size-fn sequence-type element-type element-doc-string index-doc-string}\end{defmacro}

\section{List Comprehension}
\textit{List comprehension} refers to a convenient method of generating collections of items that fit a specific criterion.
\begin{defun}{iota} \textit{start} \&optional \textit{end} \&key \texttt{:step}\\
This function has the alias $\iota$, that is, the literal small iota character (U+03B9 and optionally U+2373). If an \textit{end} is not specified, it returns a series; otherwise, it returns a list.\end{defun}
%%This is based on this: http://user.it.uu.se/~svenolof/Collect/
\begin{defmacro}{collect} \end{defmacro}
\begin{defother}{Collect option}{while}\end{defother}
\begin{defother}{Collect option}{in}\end{defother}
\begin{defother}{Collect option}{when}\end{defother}

\section{Catch, Throw, and Unwind-Protect}
\begin{special-form}{catch} \textit{tag} \{\textit{form}\}*\end{special-form}
\begin{special-form}{unwind-protect} \textit{protected-form} \{\textit{cleanup-form}\}*\end{special-form}
\begin{special-form}{throw} \textit{tag result}\end{special-form}
\chapter{Macros}
\section{Definition of Macros}
\begin{defun}{macro-function} \textit{symbol}\end{defun}
\begin{defmacro}{defmacro} \textit{name lambda-list} \textlbrackdbl \{\textit{declaration}\}* | \textit{doc-string} \textrbrackdbl \{\textit{form}\}* \end{defmacro}
\begin{defmacro}{defmacro*} \textit{name lambda-list} \textlbrackdbl \{\textit{declaration}\}* | \textit{doc-string} \textrbrackdbl \{\textit{form}\}* 
\texttt{defmacro*} is like \texttt{defmacro}, except that it ensures that the macros are \textit{hygienic}, such as to prevent variable capture.
\end{defmacro}
\begin{defmacro}{define-syntax}\end{defmacro}
\begin{defmacro}{syntax-rules}\end{defmacro}
\section{Expansion of Macros}
\begin{defun}{macroexpand} \textit{form} \&optional \textit{env}\end{defun}
\begin{defun}{macroexpand-1} \textit{form} \&optional \textit{env}\end{defun}
\begin{defvar}{*macroexpand-hook*}\end{defvar}
\section{Compiler Macros} %Hm. Might want to learn more about why this would be useful
\section{Environments}
\chapter{Declarations}
\begin{special-form}{declare} \{\textit{decl-spec}\}*\end{special-form}
\begin{special-form}{locally} \{\textit{declaration}\}* \{\textit{form}\}*\end{special-form}
\begin{defun}{proclaim} \textit{decl-spec}\end{defun}
\begin{defmacro}{declaim} \{decl-spec\}*\end{defmacro}
\begin{defmacro}{define-declaration} \textit{decl-name lambda-list} \{\textit{form}\}*\end{defmacro}
\section{Declaration Specifiers}
\texttt{special}\\
\texttt{type}\\
\textit{type}\\
\texttt{pure}\\
\texttt{multithreaded}\\
\texttt{return-type}\\
\texttt{ftype}\\
\texttt{inline}\\
\texttt{notinline}\\
\texttt{ignore}\\
\texttt{optimize}\\
\texttt{declaration}\\
\texttt{dynamic-extent}\\
\section{Forms and Type Declaration}
\begin{special-form}{the} \textit{value-type form}\end{special-form}
\chapter{Symbols}
\chapter{Packages and Systems} 

%% Read XCVB stuff, maybe change
The Common Lisp package system is \textit{not} inherited, as it turned out to be quite a mess.
\begin{defun}{load}\end{defun}
\begin{defun}{provide}\end{defun} %%Rethink. See defsystem and ASDF manual
\begin{defun}{require}\end{defun}
\begin{defun}{use-system}\end{defun}
\begin{defun}{shadow}\end{defun}
\begin{defun}{intern}\end{defun}
\begin{defun}{unuse-system}\end{defun}
\begin{defun}{unintern}\end{defun}
\begin{defun}{import} \textit{module symbols}\end{defun}
\begin{defun}{export}\end{defun}
%% Much of the ASDFy stuff is in Lake. Quicklispy stuff in CKLAN
%See http://common-lisp.net/~mmommer/asdf-howto.shtml
\begin{defun}{defsystem}\end{defun} %%Rethink. See provide and ASDF manual
\begin{defother}{System option}{:name}\end{defother}
\begin{defother}{System option}{:version}\end{defother}
\begin{defother}{System option}{:maintainer}\end{defother}
\begin{defother}{System option}{:author}\end{defother}
\begin{defother}{System option}{:licence}\end{defother} %Alias to :license
Because some projects may be multi-licenced, or certain parts of projects can be licenced differently than others, the item following the \texttt{:licence} option can be a list, and modules (see the \texttt{:module} form) can include this option. A few pre-defined licences are provided:\\
\texttt{:gpl} The GNU General Public Licence\\
\texttt{:llgpl} The Lisp-GNU Lesser General Public Licence\\
\texttt{:agpl} The Affero General Public Licence\\
\texttt{:x11} The X11 Licence (often referred to as the MIT Licence)\\
\texttt{:bsd3} The 3 Clause BSD Licence (BSD Licence sans advertising clause, also referred to as the ``Modified BSD Licence'')\\
\texttt{:bsd2} The 2 Clause BSD Licence (FreeBSD licence)\\
\texttt{:public} Public domain\\
 
\begin{defother}{System option}{:description}\end{defother}
\begin{defother}{System option}{:long-description}\end{defother}
\begin{defother}{System option}{:serial}\end{defother}
\begin{defother}{System option}{:depends-on}\end{defother}
\begin{defother}{System option}{:components}\end{defother}
\begin{defother}{System-components form}{:file}\end{defother}
\begin{defother}{System-components form}{:depends-on} %See also :depends-on, the general form
 %(defsystem cow
 % ;;; (Optional items omitted)
 % :components ((:file "tail"
 %                     :depends-on ("package" "legs"))
 %              (:file "legs"
 %                     :depends-on ("package"))
 %              (:file "head"
 %                     :depends-on ("package"))
 %              (:file "package")))
\end{defother}
\begin{defother}{System option}{:module}\end{defother}% a form of nesting! Has an option, :pathname
\begin{defother}{System-module form}{:pathname}\end{defother}
\begin{defother}{System-module form}{:components}\end{defother}
\begin{defother}{System-module form}{:aliases}\end{defother}
\begin{defother}{System-module form}{:licence}\end{defother}
\begin{defother}{System option}{:aliases}\end{defother}

\section{Colon syntax}
\texttt{foo:bar}\\
\\
\texttt{foo::bar}\\
\\
\texttt{foo::(bar quux frob)}\\
When read, evaluates \texttt{(bar quux frob)} as if it were read in the \texttt{FOO} module. This feature is currently provided in Steel Bank Common Lisp and Allegro Common Lisp. 
%% I am not sure if the following is possible, or even how it would be denoted in the exporting stuff. 
%% It should also be able to handle reader macros defined in different packages. For example, if the \texttt{arc} system used the \texttt{[]} brackets like Arc does--that is, to denote a lambda of one argument, \texttt{\textunderscore}; and another system, \texttt{clojure}, used the \texttt{[]} brackets like Clojure does--that is, to denote a vector, then the expression \texttt{arc::[clojure::[_]]}  would be equivalent to ($\lambda$ (_) (vector _))\\
\texttt{foo::bar::quux}\\
Modules can be nested, as in this example.\\
\texttt{:bar}\\
This interns the symbol \texttt{BAR} as an external symbol in the \texttt{keyword} module.\\
\texttt{\#:bar}\\
\\
\section{Built-in Modules}
\texttt{koios-lisp}\\
\\
\texttt{koios-lisp-user}\\
\\
\texttt{keyword}\\
\\
\texttt{system}\\
\\
\texttt{math}\\
\\
\chapter{Mathematics}
\textsc{Koioslisp}'s standard mathematical features have been changed somewhat from \textsc{Common Lisp}'s in light of the IEEE standard for floating-point arithmetic. However, they are on the whole fairly similar, and because of the presence of complex numbers in Koioslisp, some NaN (not a number results) are removed.
\section{The Math library}
\begin{defun}{rref}\end{defun}
\begin{defun}{mean} \textit{sample}\end{defun}
\begin{defun}{median} \textit{sample}\end{defun}
\begin{defun}{variance} \textit{sample} \&key \textit{biased}\end{defun}
\begin{defun}{standard-deviation} \textit{sample} \&key \textit{biased}\end{defun}
\begin{defun}{map-iota} \textit{function n} \&key \textit{start step}\end{defun}
\begin{defun}{clamp} \textit{number min max} \end{defun}
\begin{defun}{binomial-coefficient} \textit{n k}\end{defun}
\begin{defun}{count-permutations} \textit{n} \&optional \textit{k}\end{defun}
\begin{defun}{lerp} \textit{v a b}\end{defun}
\begin{defun}{factorial} \textit{n}\end{defun}
\begin{defun}{subfactorial} \textit{n}\end{defun}
\begin{defun}{gaussian-random} \&optional \textit{min max}\end{defun}
\begin{defun}{invert-matrix}\end{defin}
\begin{defun}{transpose}\end{defun}
\begin{defun}{conjugate-transpose}\end{defun}
\begin{defun}{eigenvalues}\end{defun}
\begin{defun}{eigenvectors}\end{defun}
\chapter{Characters}
\chapter{Sequences}
\section{Basic Sequence Functions}
\begin{defgeneric}{nth} \textit{sequence index}\end{defgeneric}
\begin{defgeneric}{with} \textit{object sequence}\end{defgeneric}
\begin{defgeneric}{with!} \textit{object sequence}\end{defgeneric}
\begin{defgeneric}{subseq} \textit{sequence start} \&optional \textit{end}\end{defgeneric}
\begin{defgeneric}{copy-seq} \textit{sequence}\end{defgeneric}
\begin{defgeneric}{length} \textit{sequence}\end{defgeneric}
\begin{defgeneric}{reverse} \textit{sequence}\end{defgeneric}
\begin{defgeneric}{reverse!} \textit{sequence}\end{defgeneric}
\begin{defgeneric}{make-sequence} \textit{type size} \&key \textit{initial-element} \end{defgeneric}
\begin{defgeneric}{union}\end{defgeneric} 
\begin{defgeneric}{union!}\end{defgeneric}
\begin{defgeneric}{intersection}\end{defgeneric}
\begin{defgeneric}{intersection!}\end{defgeneric}
\begin{defgeneric}{set-difference}\end{defgeneric}
\begin{defgeneric}{set-difference!}\end{defgeneric}
\begin{defun}{complement} \textit{function}\end{defun}
\section{Advanced Sequence Functions}
All of the pure advanced sequence generic functions (save \texttt{map}) should have an implementation where the \textit{sequence} arguments are of type \texttt{sequence}. They may optionally provide implementations for sub-classes of \texttt{sequence} in the interests of efficiency.\\
%% The from-end stuff might be complicated with lazy sequences, though they may not have to use that keyword...
\begin{defgeneric}{concatenate} \textit{result-type} \&rest \textit{sequences}\end{defgeneric}
%%% OK: the primitive will be map: everything else will be implemented in terms of map, at least for a (poor) "sequence default"
\begin{defgeneric}{map} \textit{result-type function sequence} \&rest \textit{more-sequences} \end{defgeneric} %:before, :after, and :around methods may be necessary
\begin{defgeneric}{map!} \textit{result-sequence function} \&rest \textit{sequences}
%Unlike other \textit{zapper} functions, \texttt{nmap} is not..
\end{defgeneric}
\begin{defun}{some} \textit{predicate sequence} \&rest \textit{more-sequences}\end{defun}
\begin{defun}{every} \textit{predicate sequence} \&rest \textit{more-seqences}\end{defun}
\begin{defun}{notany} \textit{predicate sequence} \&rest \textit{more-sequences}\end{defun}
\begin{defun}{notevery} \textit{predicate sequence} \&rest \textit{more-sequences}\end{defun}
\begin{defun}{reduce} \textit{function sequence} \&key \texttt{:from-end :start :end :initial-value :key}\end{defun}
\begin{defgeneric}{map-reduce}\end{defgeneric} %% See Steele talk; combines MAP and REDUCE, and optimizes...
\begin{defgeneric}{fill} \textit{sequence item} \&key \texttt{:start :end}\end{defgeneric}
\begin{defgeneric}{fill!} \textit{sequence item} \&key \texttt{:start :end}\end{defgeneric}
\begin{defgeneric}{replace} \textit{sequence1 sequence2} \&key \texttt{:start1 :end1 :start2 :end2}\end{defgeneric}
\begin{defgeneric}{replace!} \textit{sequence1 sequence2} \&key \texttt{:start1 :end1 :start2 :end2}\end{defgeneric}
\begin{defgeneric}{remove} \textit{item sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{remove-if} \textit{predicate sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{remove-duplicates} \textit{sequence} \&key \texttt{:from-end :test :start :end :key}\end{defgeneric}
\begin{defgeneric}{remove!} \textit{item sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{remove-if!} \textit{predicate sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{filter} \textit{item sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{filter-if} \textit{predicate sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{filter!} \textit{item sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{filter-if!} \textit{predicate sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{partition} \textit{item sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{partition-if} \textit{predicate sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{remove-duplicates!} \textit{sequence} \&key \texttt{:from-end :test :start :end :key}\end{defgeneric}
\begin{defgeneric}{substitute} \textit{newitem olditem sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{substitute-if} \textit{new-item test sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{substitute!} \textit{newitem olditem sequence} \&key \texttt{:from-end :test :start :end :count :key}\end{defgeneric}
\begin{defgeneric}{substitute-if!} \textit{new-item test sequence} \&key \texttt{:from-end :start :end :count :key}\end{defgeneric}
\section{Searching Sequences}
\begin{defgeneric}{member}\end{defgeneric}
\begin{defgeneric}{member-if}\end{defgeneric}
\begin{defgeneric}{find} \textit{item sequence} \&key \texttt{:from-end :test :test-not}\end{defgeneric}
\begin{defgeneric}{find-if} \textit{predicate sequence} \&key \texttt{:from-end :start :end :key}\end{defgeneric}
\begin{defgeneric}{position} \textit{item sequence} \&key \texttt{:from-end :test :test-not :start :end :key}\end{defgeneric}
\begin{defgeneric}{position-if} \textit{predicate sequence} \&key \texttt{:from-end :start :end :key}\end{defgeneric}
\begin{defgeneric}{count} \textit{item sequence} \&key \texttt{:from-end :test :test-not :start :end :key}\end{defgeneric}
\begin{defgeneric}{count-if} \textit{predicate sequence} \&key \texttt{:from-end :start :end :key}\end{defgeneric}
\begin{defgeneric}{mismatch} \textit{sequence1 sequence2} \&key \texttt{:from-end :test :test-not :key :start1 :start2 :end1 :end2}\end{defgeneric}
\begin{defgeneric}{search} \textit{sequence1 sequence2} \&key \texttt{:from-end :test :test-not :key :start1 :start2 :end1 :end2}\end{defgeneric}
\section{Sorting and Merging}
\begin{defgeneric}{sort} \textit{sequence predicate} \&key \texttt{:key}\end{defgeneric} %Non-destructive
\begin{defgeneric}{stable-sort} \textit{sequence predicate} \&key \texttt{:key}\end{defgeneric} %Non-destructive
\begin{defgeneric}{sort!} \textit{sequence predicate} \&key \texttt{:key}\end{defgeneric} %CL::SORT
\begin{defgeneric}{stable-sort!} \textit{sequence predicate} \&key \texttt{:key}\end{defgeneric} %CL::STABLE-SORT
\begin{defgeneric}{merge} \textit{result-type sequence1 sequence2 predicate} \&key \textit{:key} \end{defgeneric} %Non-destructive
\begin{defgeneric}{merge!} \textit{result-type sequence1 sequence2 predicate} \&key \textit{:key} \end{defgeneric} %CL::MERGE
\chapter{Lists}
\textit{Lists} are the primary--and the first--data structure of Lisp. A list is a chain of \textit{conses} (which are data structures with two fields, the \textit{car} and the \textit{cdr})--linked to each other via \textit{cdr}s.
\section{Conses}
\begin{defun}{car} \textit{list} \end{defun}
\begin{defun}{cdr} \textit{list}\end{defun}
%%
\begin{defun}{caar} \textit{list}\end{defun}
\begin{defun}{cadr} \textit{list}\end{defun}
\begin{defun}{cdar} \textit{list}\end{defun}
\begin{defun}{cddr} \textit{list}\end{defun}
\begin{defun}{caaar} \textit{list}\end{defun}
\begin{defun}{caadr} \textit{list}\end{defun}
\begin{defun}{cadar} \textit{list}\end{defun}
\begin{defun}{caddr} \textit{list}\end{defun}
\begin{defun}{cdaar} \textit{list}\end{defun}
\begin{defun}{cdadr} \textit{list}\end{defun}
\begin{defun}{cddar} \textit{list}\end{defun}
\begin{defun}{cdddr} \textit{list}\end{defun}
\begin{defun}{caaaar} \textit{list}\end{defun}
\begin{defun}{caaadr} \textit{list}\end{defun}
\begin{defun}{caadar} \textit{list}\end{defun}
\begin{defun}{caaddr} \textit{list}\end{defun}
\begin{defun}{cadaar} \textit{list}\end{defun}
\begin{defun}{cadadr} \textit{list}\end{defun}
\begin{defun}{caddar} \textit{list}\end{defun}
\begin{defun}{cadddr} \textit{list}\end{defun}
\begin{defun}{cdaaar} \textit{list}\end{defun}
\begin{defun}{cdaadr} \textit{list}\end{defun}
\begin{defun}{cdadar} \textit{list}\end{defun}
\begin{defun}{cdaddr} \textit{list}\end{defun}
\begin{defun}{cddaar} \textit{list}\end{defun}
\begin{defun}{cddadr} \textit{list}\end{defun}
\begin{defun}{cdddar} \textit{list}\end{defun}
\begin{defun}{cddddr} \textit{list}\end{defun}
%%
\begin{defun}{cons} \textit{x y}\end{defun}
\begin{defun}{tree-equal} \textit{x y}\end{defun}
\section{Lists}
\begin{defun}{end?}\end{defun}
\begin{defmethod}{length}\end{defmethod}
\begin{defmethod}{nth}\end{defmethod} %Takes ELT arg-ordering
%% Perhaps make FIRST, SECOND....REST generic for sequences
\begin{defun}{first}\end{defun}
\begin{defun}{second}\end{defun}
\begin{defun}{third}\end{defun}
\begin{defun}{fourth}\end{defun}
\begin{defun}{fifth}\end{defun}
\begin{defun}{sixth}\end{defun}
\begin{defun}{seventh}\end{defun}
\begin{defun}{eighth}\end{defun}
\begin{defun}{ninth}\end{defun}
\begin{defun}{tenth}\end{defun}
%%
\begin{defun}{rest}\end{defun}
\begin{defun}{nthcdr}\end{defun}
\begin{defmethod}{last}\end{defmethod}
\begin{defun}{list}\end{defun}
\begin{defun}{list*}\end{defun}
\begin{defun}{list?} \textit{object}\end{defun}
\begin{defun}{make-list}\end{defun} %Possibly remove; I don't think I've seen anyone use it, and you can use fill
\begin{defmethod}{append}\end{defmethod}
\begin{defun}{copy-list}\end{defun}%Generalize?
\begin{defun}{copy-tree}\end{defun}
\begin{defmethod}{revappend}\end{defmethod}
\begin{defmethod}{append!}\end{defmethod}
\begin{defmethod}{revappend!}\end{defmethod}
\begin{defmacro}{push!}\end{defmacro} %Maybe move some of the stuff to "Sequences"
\begin{defmacro}{pushnew!}\end{defmacro} %Hm
\begin{defmacro}{pop!}\end{defmacro}
\begin{defun}{butlast}\end{defun}%Generalize?
\begin{defun}{nbutlast}\end{defun}
\begin{defun}{ldiff}\end{defun}
%
\begin{defmethod}{subst}\end{defmethod}
\begin{defmethod}{subst-if}\end{defmethod}
%
\begin{defmethod}{subst!}\end{defmethod}
\begin{defmethod}{subst-if!}\end{defmethod}
%
\begin{defun}{sublis}\end{defun}
\begin{defmethod}{member}\end{defmethod}
\begin{defmethod}{member-if}\end{defmethod}
\begin{defun}{tail?}\end{defun}%Also, create generic "contains"
%%Rename in light of SERIES "tail" function. Or rename that...
\section{Association Lists}
\begin{defun}{acons}\end{defun}
\begin{defun}{pairlis}\end{defun}
\begin{defmethod}{assoc}\end{defmethod}
\begin{defmethod}{assoc-if}\end{defmethod}
\begin{defmethod}{rassoc}\end{defmethod}
\begin{defmethod}{rassoc-if}\end{defmethod}
\begin{defun}{copy-alist}\end{defun}

\section{Mapping}
\begin{defun}{maplist} \textit{function list} \&rest \textit{more-lists}\end{defun}
\chapter{Sets}
\begin{defun}{make-set}\end{defun}
\begin{defun}{adjoin}\end{defun}
\begin{defun}{less}\end{defun}
\begin{defun}{empty-set}\end{defun}
\begin{defun}{subset?}\end{defun}
\begin{defun}{disjoint?}\end{defun}

\chapter{Hash Tables}
%The printed representation of a hash table is #hash((vladimir . estragon) (rosencrantz . guildenstern))
%Uniqueness should be tested by KL::=? (CL::EQUAL) by default, although other values may be allowed
Hash tables in Koioslisp, like in Haskell and Clojure, can be operated similar to linked lists, specifically, association lists; as opposed to the support in \textsc{Common Lisp}, where most of the functions are destructive. Unlike in \textsc{Common Lisp}, hash tables in \textsc{Koioslisp}, hash tables have standard, \texttt{read}able, printed representations, borrowed from \textsc{Racket} and \textsc{Arc}. For example, a plausible hash-table is provided\\ \texttt{\#hash((vladimir . estragon) (rosencrantz . guildenstern))}\\ In this hash-table, the \textit{symbol} \texttt{vladimir} is mapped to the symbol \texttt{estragon}, and the symbol \texttt{rosencrantz} is mapped to the symbol \texttt{guildenstern}. If the hash table had an equality test of \texttt{eq?}, then it would be notated as\\
\texttt{\#hash(:eq? (vladimir . estragon)(rosencrantz . guildenstern))}
\begin{defun}{make-hash-table} \&key {\it initial-contents}\end{defun}
\begin{defun}{empty-hash}\end{defun}
\begin{defun}{hash-table?} \textit{object}\end{defun}
\begin{defmethod}{assoc} \textit{item} \textit{table} \&key {\it key test} \end{defmethod}
\begin{defmethod}{assoc-if} \textit{predicate} \textit{table} \&key \textit{key}\end{defmethod}
\begin{defmethod}{rassoc} \textit{item} \textit{table} \&key {\it key test test-not}\end{defmethod}
\begin{defmethod}{rassoc-if} \textit{predicate} \textit{table} \&key \textit{key} \end{defmethod}
\begin{defmethod}{pair} \textit{keys} \textit{values} \&optional \textit{table}\end{defmethod}
\begin{defmethod}{remove} \textit{key} \textit{table}\end{defmethod}
\begin{defmethod}{remove!} \textit{key} \textit{table} \end{defmethod}
\begin{defmethod}{reduce} \end{defmethod}
\begin{defun}{h-cons} \textit{key} \textit{value} \textit{table}\\
\texttt{h-cons} takes a key, a value, and a hash table (respectively) as its arguments, and returns a new hash-table with the contents of \textit{table} and a new association between \textit{key} and \textit{value}. If \textit{key} is already contained (as in, the keys are \texttt{=}) as a key in \textit{table}, the table returned will use the value \textit{value} instead of the value mapped to \textit{key} in table.\\
\texttt{(h-cons 'foo 'bar baz)} is equivalent to \texttt{(pair 'foo 'bar baz)} \end{defun}
\begin{defun}{h-append} \textit{table1} \textit{table2} \&key \textit{test}\\
\texttt{h-append} is like \texttt{h-cons}, except that it takes two hash-tables as arguments instead of a key, a value, and a hash-table. It returns a new hash-table with the contents of both the first table and the second table. If the second hash-table contains an entry with the same (\texttt{=}) key as the first hash-table, then the entry from the second hash-table is used. If the optional parameter \textit{new-table-test} (which may be the values EQ or =) is supplied, the hash-table returned has membership specified by the given parameter as a test.\end{defun}
\begin{defun}{h-push!} \textit{key} \textit{value} \textit{table}\\
\texttt{h-push} is the destructive counterpart to \texttt{h-cons}, modifying \textit{table} as a result. \texttt{(h-push 'foo 'bar baz)} is equivalent to \texttt{(zap \#'($\lambda$ (x) (h-cons 'foo 'bar x)) baz)}.\end{defun}
\begin{defun}{h-append!} \textit{table1} \textit{table 2}\\
\texttt{h-append!} is the destructive counterpart to \texttt{h-append}, modifying \textit{table1} as a result. \texttt{(h-append! foo baz)} is equivalent to \texttt{(zap \#'($\lambda$ (x) (h-append x bar)) foo)}, unless \textit{table1} uses a different test than the default (such as =, which will be used for this example), in which case it would be \texttt{(zap \#'($\lambda$ (x) (h-append x bar :test '=)) foo)} 
\end{defun}
\begin{defmethod}{map-keys} \textit{result-class} \textit{function} \textit{hash-table} \&rest \textit{more-sequences}\\ %Change to a function w/explicit "key" in name
This is the method of map specialized for \textit{hash-tables}. It behaves like the rest of the methods of \textit{map},except that the function is called on the set of keys in the hash-table rather than both the keys and the values.\end{defmethod}
\begin{defun}{maphash} \textit{function hash-table}\\
The \textit{maphash} function maps over every entry of the hash-table \textit{hash-table}; calling the function \textit{function} with the arguments being the key and the value of the entry; then it returns a list of the results of the evaluation of the function over the entries. In this it is incompatible with {\sc Common Lisp}'s \texttt{maphash} function, which unconditionally returns \texttt{nil}. If the entries in \textit{hash-table} are destructively modified by \textit{function}, the results are unpredictable.  \end{defun}
\begin{defmacro}{with-hash-table-iterator}\end{defmacro}
\begin{defmethod}{member}\end{defmethod}
\begin{defmethod}{member-if}\end{defmethod}
\begin{defmethod}{sort} \textit{table}\end{defmethod}
\begin{defmethod}{sort!} \textit{table}\end{defmethod}
\begin{defmethod}{clear}\end{defmethod}
\begin{defun}{sxhash} \textit{object}\end{defun}
\begin{defmethod}{get-in} \textit{table} \&rest \textit{keys}\end{defmethod}
\begin{defun}{keys} \textit{table}\end{defun}%Function or method? (alists for the other type)
\begin{defun}{hash-values}\textit{table}\end{defun}
\begin{defmethod}{length}\end{defmethod}
\begin{defun}{merge-with}\end{defun}
\chapter{Arrays}
\begin{defun}{make-array}\end{defun}
% Shouldn't the following be functions instead?
\begin{defconstant}{+array-rank-limit+}\end{defconstant} 
\begin{defconstant}{+array-dimension-limit+}\end{defconstant}
\begin{defconstant}{+array-total-size-limit+}\end{defconstant}
%
\begin{defun}{aref}\end{defun}
\begin{defun}{array-element-type}\end{defun}
\begin{defun}{array-rank}\end{defun}
\begin{defun}{array-dimension}\end{defun}
\begin{defun}{array-dimensions}\end{defun}
\begin{defun}{array-total-size}\end{defun}
\begin{defun}{array-in-bounds-p}\end{defun}
\begin{defun}{array-row-major-index}\end{defun}
\begin{defun}{row-major-aref}\end{defun}
\begin{defun}{adjustable-array-p}\end{defun}
\section{Vectors}
%Fill pointers, bit-arrays, and other stuff I know nothing about
%% Actually, make FSet-like vectors. Make them GOOD

%% Perhaps remove? I'm not sure.... What would we do with strings and bit-vectors?
What Common Lisp called \texttt{vector-push-extend} has been rechristened \texttt{vector-push}; Common Lisp's \texttt{vector-push} (a less-useful case of \texttt{vector-push-extend}) has been removed from the language.
\chapter{Tuples}
In \textsc{Koioslisp}, tuples are designed to potentially produce particularly efficient parallel code. They are modelled, in part, after the ``conc lists'' %Is this really what they're called?
of the Fortress programing language.
%% Perhaps change everything (left. right, etc.) into generics, but tuples are well suited because balancing-binary-tree 

%% OK, how the hell is this going to interact with concurrency?
%% Is it implicitly concurrent?
%% If so, what about non-Tuple sequences?
%%% This is an issue I can worry about somewhat later, but I MUST worry about it eventually.


\begin{defun}{tuple}\end{defun}
\begin{defun}{tuple?}\end{defun}
\begin{defun}{conc}\end{defun}
\begin{defmethod}{empty?}\end{defmethod}
\begin{defun}{singleton?}\end{defun}
\begin{defun}{item}\end{defun}
\begin{defun}{left}\end{defun}
\begin{defun}{right}\end{defun}
\begin{defun}{rebalance}\end{defun} %Should this be a user-fun?
\begin{defun}{add-left}\end{defun}
\begin{defun}{add-right}\end{defun}
\begin{defun}{split}\end{defun}
\begin{defun}{divide-and-conc}\end{defun}

\chapter{Strings}
%Should strings be immutable?
%% I think the Ruby solution is good (for now):
%% Mutable by default, but with a "freeze" mechanism
%% However, I'm not sure whether one could still reap the benefits of array-strings
A string is a sequence of characters.
\begin{defgeneric}{str}\end{defgeneric} %Take in mind Kalenius's comments on this
\section{String Pattern Matching}
Koioslisp supports pattern matching both at the string level (here), and the tree level (the ``Pattern Matching'' chapter), with the inspiration for the string-based pattern matching being SNOBOL.\\
\begin{defun}{match}\end{defun} %Rename. 
\begin{defun}{replace}\end{defun}%Perhaps rename
\begin{defun}{replace!}\end{defun}
\begin{defun}{replace*}\end{defun}
\begin{defun}{replace*!}\end{defun}
%% Perhaps not defun; it specifies a pattern!
%% Or maybe not? 
\begin{defun}{make-pattern}\end{defun} % *Probably* can be a function. Allows recursion in patterns.
\begin{defun}{str-span}\end{defun}
\begin{defun}{str-break}\end{defun}
\begin{defun}{l-pos}\end{defun}
\begin{defun}{r-pos}\end{defun}
\begin{defun}{str-or}\end{defun}
\begin{defun}{str-not}\end{defun}
\begin{defun}{match-len}\end{defun}
\begin{defun}{all-matches}\end{defun} %Rename: see above
\begin{defun}{str-fail!}\end{defun}
\begin{defun}{arbstr}\end{defun}
\begin{defun}{arb-num-str}\end{defun}

\subsection{Regular Expressions}
Another, often quicker, method for recognizing patterns in strings is through the use of \textit{regular expressions}.
%Should I include regexen?
\begin{defun}{splitre} \end{defun}
%% Lispify the SNOBOL syntax:
%(Copied from SnoPy doc)
%% See the SNOBOL4 tutorial for a more...*coherent* explanation
% A & B -- Match a followed by matching b
% A or B -- Match A, and if that doesn't succeed, match B
%Uses backtracking. E.g.: 
%% (A or B) & (C or D) & (E or F)
%%Attempt to match A. If it succeeds, attempt to match C. If it succeeds, attempt to match E.
%%If E fails, attempt to match F. If F fails, attempt to match D (instead of C), and then try with E
%% ("ABC" or "AB") & ("DEF" or "CDE") & ("GH" or "IJ")
%% will try (in this order):
%% ABC(.*)DEF(.*)GH
%% ABC(.*)DEF(.*)IJ
%% ABC(.*)CDE(.*)GH
%% ABC(.*)CDE(.*)IJ
%% AB(.*)DEF(.*)GH
%% AB(.*)DEF(.*)IJ
%% AB(.*)CDE(.*)GH
%% AB(.*)CDE(.*)IJ
% Arb : matches any string. First matches null string, then one char...fails if entire string is matched
% Bal : matches paren-balanced strings
% Cancel : aborts; signals failure
% Fail : unconditionally fail
% Fence : matches null string; if a failure causes alternatives to be matched, aborts
% Rest : match from the current point to the last char. in the string 
% Succeed : unconditionally succeed
% (any s) : where s is a string, match a char that is any one of the chars in s. Fails if the current char is not one of the given set
% (arbno p) : where p is a pattern, match any number of occurences of the pattern
% (break s) : where s is a string, match a string of zero or more chars up to but not including a break char which is contained.
% (breakx s) : See break--but if it is successfully matched, subsequent failure causes an attempt to extend the matched string
% (fence p) : where p is a pattern, attempts to match the pattern of p including trying all possible alternatives. If one alternative succeeds, the pattern match proceeds, but on a subsequent failure it abandons the quest
% (len n) : matches a string that is exactly n chars long
% (not-any s) : matches a char that is not one of the chars in s
% (span* s) : where s is a string, match a string of zero or more chars that is among the chars given. always chooses the largest possible string, and succeeds.
% (pos n) : where n is an int, matches the null string if exactly n characters have been matched so far; else fails
% (rpos n) : like pos, but n characters remain-to-be-matched
% (rtab n) where n is an int, matches chars from the current position until n chars remain to be matched in the string. Fails if fewer than n chars are in string
% (tab n) : like rtab n, but "until n chars have been matched in all"
% (span s) : where s is a string, matches a string of one or more chars that is among the chars given (IN ANY ORDER). Matches the longest such string possible.    


\chapter{The Evaluator}
\chapter{Lazy Evaluation}
\textit{Lazy evaluation} is a method for efficiently manipulating large (even theoretically infinite) data structures. Though usually evaluation is eager, Koioslisp provides support for lazy evaluation with explicit annotation. The Koioslisp lazy evaluation facility is partially based on the CLAZY library for Common Lisp, and the Clojure lazy evaluation facility. See also the section on List Comprehension. 

\begin{defmacro}{deflazy}\end{defmacro}
\begin{defun}{lazycall}\end{defun} %% Maybe integrate into FUNCALL. Also: is it possible to be a function, or must it be a macro?
\begin{defmacro}{lazy}\end{defmacro} %%Poke around in CLAZY source....
\begin{defmacro}{lazylambda}\end{defmacro} %With alias lazyλ...
\begin{defmacro}{lazylet}\end{defmacro}
\begin{defun}{force}\end{defun}
\section{Series}
Series are sequences, and thus all sequence generic functions should ``work'' on them, in manners defined here. Generally they are to be defined lazily; that is, to generate a result, one must \texttt{take} (or \texttt{take-all}) elements from them. 
\begin{defmethod}{take}\\
Unlike \texttt{take-all}, \texttt{take} is useful for large sequences in general--thus it has been promoted to a sequence generic function. 
\end{defmethod}
\begin{defun}{take-all}\end{defun}
\begin{defun}{drop}\end{defun}
\begin{defun}{head}\end{defun}
\begin{defun}{tail}\end{defun}
\chapter{Continuations}
%% Replace with delimited continuations once you grok them
Like Scheme and Qi, \textsc{Koioslisp} provides continuations, which are mechanisms for abstract control over the flow of execution of a program. Unlike Scheme or Qi, these are \textit{delimited continuations}\\

\begin{defun}{call/cc} \textit{function}\\
The argument \textit{function} is a function which takes one parameter. CALL/CC can only be called within a WITH-CALL/CC form or an implicit WITH-CALL/CC form. CALL/CC has the alias CALL-WITH-CURRENT-CONTINUATION\end{defun}
\begin{defmacro}{with-call/cc} \end{defmacro}
\begin{defmacro}{let/cc}\end{defmacro}
\begin{defmacro}{lambda/cc}\end{defmacro}
\begin{defmacro}{defun/cc}\end{defmacro}
\begin{defmacro}{without-call/cc}\end{defmacro}
\begin{defmacro}{defmethod/cc}\end{defmacro} %How would this work?
\begin{defmacro}{defgeneric/cc}\end{defmacro} 
%%% Maybe instead: use SHIFT and RESET as in Wikipedia's article on delimited continuations
\chapter{Logic Programming}
\section{Constraints}
% http://nikodemus.github.com/screamer/
% Perhaps replace logic/pattern-matching feature with this, and have them as a special case
The features described in this section are based on the Common Lisp library Screamer, which adds constraint-programming constructs to Common Lisp.
\subsection{Nondeterminism}
A nondeterministic context is:\\
1. The body of a function defined with \texttt{def-nondet-fun}.\\%%, or a generic function defined with \texttt{def-nondet-generic} and \texttt{def-nondet-method}. \\
2. The body of a \texttt{for-effects}, \texttt{all-values}, \texttt{print-values}, \texttt{possibly?}, or \texttt{necessary?} form\\
3. The first argument of a \texttt{one-value} form\\
4. The second argument of a \texttt{ith-value} form\\
\begin{defmacro}{either} \&body \textit{alternatives}\end{defmacro}
\begin{defun}{fail} \end{defun}
\begin{defun}{trail} \textit{function} \end{defun}
\begin{defmacro}{all-values} \&body \textit{body} \end{defmacro}
\begin{defmacro}{one-value} \textit{form} \&optional \textit{default}\end{defmacro}
\begin{defmacro}{for-effects} \&body \textit{body}\end{defmacro}
\begin{defmacro}{ith-value} \textit{i form} \&optional \textit{default} \end{defmacro}
\begin{defmacro}{print-values} \&body \textit{body}\end{defmacro}
\begin{defmacro}{possibly?} \&body \textit{body}\end{defmacro}
\begin{defmacro}{necessarily?} \&body \textit{body}\end{defmacro}
Some macros have been provided to facilitate the creation of non-deterministic functions and generic function, as they cannot, by definition, be called in a deterministic context.\\
\begin{defmacro}{def-nondet-fun}\end{defmacro} %Like SCREAMER::DEFUN. Or maybe just integrate it into DEFUN...
\begin{defmacro}{def-nondet-generic}\end{defmacro} %For generic functions. Well, actually, how the hell would this work?! Does it even make sense?
\begin{defmacro}{def-nondet-method}\end{defmacro}
\begin{defun}{a-boolean}\end{defun}
\begin{defgeneric}{a-member-of} \textit{sequence}\end{defgeneric}
\begin{defun}{an-integer}\end{defun}
\begin{defun}{an-integer-above} \textit{low}\end{defun}
\begin{defun}{an-integer-below} \textit{high}\end{defun}
\begin{defun}{an-integer-between} \textit{low high}\end{defun}
\begin{defun}{nondet?} \textit{x}\end{defun}
\begin{defun}{nondet-generic?} \textit{x}\end{defun} %Do I need this?
\begin{defmacro}{when-failing} (\&body \textit{failing-forms}) \&body \textit{body}\end{defmacro}
\begin{defmacro}{count-failures} \&body \textit{body} \end{defmacro}

%%APPLY, FUNCALL, and MULTIPLE-VALUE-CALL will be like SCREAMER::APPLY-NONDETERMINISTIC, SCREAMER::FUNCALL-NONDETERMINISTIC, and SCREAMER::MULTIPLE-VALUE-CALL-NONDETERMINISTIC
\subsection{The Creation and Manipulation of Constraint Variables}
\begin{defmacro}{assert!} \textit{v}\end{defmacro} 
\begin{defun}{of-typev} \textit{type} \&optional \textit{name}\end{defun} %Constrains a variable to the type specified. Like a declaration....perhaps integrate into declaration?
\begin{defun}{value-of} \textit{x} \end{defun} %Perhaps this can get the list of constraints
\begin{defun}{apply-substitution} \textit{x} \end{defun}
\begin{defun}{bound?} \textit{x}\end{defun}
\begin{defun}{ground?} \textit{x}\end{defun}
\begin{defun}{applyv} \textit{f x} \&rest \textit{more-vars}\end{defun}
\begin{defun}{funcallv} \textit{f} \&rest \textit{vars}\end{defun}
\begin{defun}{equalv} \textit{x y}\end{defun} %With alias =v
\begin{defun}{template} \textit{template} \end{defun} %Should be called automatically with unification functions

\begin{defun}{make-logvar} \&optional \textit{name}\end{defun} %SCREAMER::MAKE-VARIABLE

\begin{defun}{unify} \textit{x y}\\\texttt{(unify x y)} is syntactic sugar for \texttt{(assertv (equalv x y))}\end{defun}
%% Most likely won't need to use ?x syntax for constraint variables.
%%Define a function to get a list of the constraints upon constraint variables, like SCREAMER variable syntax
\subsubsection{Sequences}
\begin{defun}{a-member-ofv} \textit{vals} \&optional \textit{name}\end{defun}
\begin{defun}{memberv} \textit{x sequence}\end{defun} %Integrate into MEMBER ?

\subsubsection{Booleans}
\begin{defun}{a-booleanv} \&optional \textit{name}\end{defun}
\begin{defun}{booleanpv} \textit{v} \end{defun}
\begin{defmacro}{knownp} \textit{x} \end{defmacro} %Implemented as a macro to allow compile-time optimizations.
\begin{defmacro}{decide} \textit{x} \end{defmacro}
\begin{defun}{notv} \textit{x} \end{defun}
\begin{defun}{andv} \&rest \textit{vars}\end{defun}
\begin{defun}{orv} \&rest \textit{vars}\end{defun}
\begin{defun}{count-truesv} \&rest \textit{vars}\end{defun}
\subsubsection{Numbers}
\begin{defun}{a-numberv} \&optional \textit{name}\end{defun}
\begin{defun}{a-realv} \&optional \textit{name}\end{defun}
\begin{defun}{a-real-abovev} \textit{low} \&optional \textit{name}\end{defun}
\begin{defun}{a-real-belowv} \textit{high} \&optional \textit{name}\end{defun}
\begin{defun}{a-real-betweenv} \textit{low high} \&optional \textit{name}\end{defun}
\begin{defun}{an-integerv} \&optional \textit{name}\end{defun}
\begin{defun}{a-integer-abovev} \textit{low} \&optional \textit{name}\end{defun}
\begin{defun}{a-integer-belowv} \textit{high} \&optional \textit{name}\end{defun}
\begin{defun}{a-integer-betweenv} \textit{low high} \&optional \textit{name}\end{defun}
\begin{defun}{numberv?} \textit{x}\end{defun} %Maybe number?v instead of numberv?
\begin{defun}{realv?} \textit{x}\end{defun}
\begin{defun}{integerv?} \textit{x}\end{defun}
\begin{defun}{minv} \textit{x} \&rest \textit{more-vars}\end{defun}
\begin{defun}{maxv} \textit{x} \&rest \textit{more-vars}\end{defun}
\begin{defun}{+v} \&rest \textit{vars}\end{defun}
\begin{defun}{-v} \textit{x} \&rest \textit{vars}\end{defun}
\begin{defun}{*v} \&rest \textit{vars}\end{defun}
\begin{defun}{/v} \textit{x} \&rest \textit{vars}\end{defun}
\begin{defun}{<v} \textit{x} \&rest \textit{vars}\end{defun}
\begin{defun}{<=v} \textit{x} \&rest \textit{vars}\end{defun}
\begin{defun}{>=v} \textit{x} \&rest \textit{vars}\end{defun}
\begin{defun}{>v} \textit{x} \&rest \textit{vars}\end{defun}
\begin{defun}{/=v} \textit{x} \&rest \textit{vars}\end{defun}
\subsection{Forcing Solutions}
\begin{defun}{solution} \textit{arguments ordering-force-function}\end{defun}
\begin{defun}{static-ordering} \textit{force-function}\end{defun}
\begin{defun}{reorder} \textit{cost-function terminate-p order force-function}\end{defun}
\begin{defun}{linear-force} \textit{x} \end{defun}

\subsection{Side Effects in Constraint Programming} 
\begin{defmacro}{globalc} \&body \textit{body} \end{defmacro} %SCREAMER::GLOBAL
\begin{defmacro}{localc} \&body \textit{body} \end{defmacro} %SCREAMER::LOCAL
\subsection{Relations}
For more convenience, \textsc{Koioslisp} also provides \textit{relations}, allowing a more Prolog-esque style\\
\chapter{Sockets}

\chapter{Streams}
\chapter{Objects}
The Koioslisp Object System is based on CLOS (Common Lisp Object System) and TELOS (The EuLisp Object System), and provides reasonably better integration with the rest of Koioslisp than CLOS does with Common Lisp.
\section{Classes}
\subsection{Defining Classes}
\subsection{Instance Creation}
\subsection{Slots}
\subsection{Accessing Slots}
\subsection{Inheritance}
\subsubsection{Inheritance of Methods}
\subsubsection{Inheritance of Slots}
\subsubsection{Examples}
\subsection{Built-in Classes}
\subsection{Determining the Class Precedence List}
\subsubsection{Sorting the  Class Precedence Lists}
\subsubsection{Examples}
\section{Generic Functions and Methods}
\subsection{Introduction}
\subsection{Agreement on Parameter Specializers and Qualifiers}
\subsection{Keyword Arguments}
\subsection{Method Selection}
\subsection{Determinating the Effective Method}
\subsection{Standard Method Combination}
\subsection{Other Method Combinations}
\subsection{Defining Method Combinations}
\subsection{SET methods}
\section{Structures}
\subsection{Defstruct Options}
\subsection{BOA Constructors}
\section{The Meta-Object Protocol}

\chapter{Input/Output}
\begin{lisp}
(defvar *country* ``Eurasia'')\\
(format t ``Oceania has always been at war with \textasciitilde A'' *country*)\\ ;\textrm{→} ``Oceania has always been at war with Eurasia''
\end{lisp}
\section{Readtables}
\textsc{Koioslisp} adopts the mechanism of \textit{named readtables}. There are two preregistered readtables: \texttt{:koioslisp} and \texttt{:current}: they refer to standard \textsc{Koioslisp} syntax and the current readtable respectively.
\begin{defmacro}{defreadtable} \textit{name} \&body \textit{options}\\
\texttt{defreadtable}, as indicated by its name, defines a new readtable with its name the symbol \textit{name}, unless \textit{name} is already used for another readtable, in which case it is redefined. \texttt{defreadtable} takes several options:\\
\texttt{(:merge} \textit{readtables+})\\
\texttt{(:merge-overwriting} \textit{readtables+})\\
\texttt{(:dispatch-macro-char} \textit{macro-char function})\\
\texttt{(:macro-char} \textit{macro-char function}
\end{defmacro}
\begin{defun}{copy-readtable}\end{defun}
\begin{defun}{ensure-readtable}\end{defun}
\begin{defun}{find-readtable} \textit{name}\\
Looks for a readtable of name \textit{name} (which is of type \texttt{(or readtable symbol)}), and returns it if it is found, or \texttt{nil} otherwise.
\end{defun}
\chapter{File System Interface}

Often, programs are packaged in \textit{files}. Because of their use, {\sc Koioslisp} provides a standard method for interacting with a filesystem. The system is designed with its basis on the Common Lisp filesystem interface because of its generality and ability to handle most, if not all, forms of filesystems. These are useful features because of the historical and current variation in file systems and their conventions in representing files.
%Perhaps reorganize into a section called "File Names"--which will exist, regardless, but perhaps it should include the table
 As an example of such variation, a table of different methods to represent a certain file on different filesystems important (both currently and historically) in the Lisp world is given:
\begin{longtable}{|p{2cm}|l|}\hline
System&File name\\\hline
TOPS-20&\texttt{\textlangle LISPIO\textrangle FORMAT.FASL.13}\\\hline
TOPS-10&\texttt{FORMAT.FAS[1,4]}\\\hline
ITS&\texttt{LISPIO;FORMAT FASL}\\\hline
MULTICS&\texttt{\textrangle udd\textrangle LispIO\textrangle format.fasl}\\\hline
TENEX&\texttt{\textlangle LISPIO\textrangle FORMAT.FASL;13}\\\hline
VAX/VMS&\texttt{[LISPIO]FORMAT.FAS;13}\\\hline
Unix, GNU, *BSD, Plan 9, Mac OS X, etc.&\texttt{/usr/LispIO/format.fasl}\\\hline
MS-DOS, Windows, ReactOS, etc.&\texttt{C:\textbackslash Program Files\textbackslash LispIO\textbackslash format.fasl}\\\hline
\end{longtable}
This large proliferation of differing filesystems makes optimizing to one specific type in the core language rather arbitrary and shortsighted. Thus, Koioslisp uses a very general method for dealing with filesystems; namely, adapting the Common Lisp system--providing \textit{namestrings} (which are strings in the customary file system-representing form) and \textit{pathnames} (which are abstract methods of dealing with files)  that work in a very similar manner to their predecessors.
\section{File Names}
\subsection{Pathnames}
Filesystems in Koioslisp are seen through the framework of the \textit{pathname} data object, with its components defined below.  This is used in order to enhance portability over file systems.\\
\textit{host}\\
A \textit{host} is the name of the file system which contains the file\\
\textit{device}\\
The ``file structure'', or ``device'' component of file systems\\
\textit{directory}\\
The ``directory'' component of most file systems; a structure containing a group of possibly related files\\
\textit{name}\\
The label associated with a file\\
\textit{type}
The ``extension''or ``filetype'' of a file system--quite literally the type of file, which determines which programs are to handle it.\\
\textit{version}\\
An increasingly rare component; a number which represents which revision the file is in, and how many revisions it has undergone\\
\subsection{Case Conventions}
\subsection{Structured Directories}
\subsection{Extended Wildcards and Globbing}
\subsection{Logical Pathnames}
\subsubsection{Syntax of Logical Pathnames}
\subsubsection{Parsing of Logical Pathname Namestrings}
\subsubsection{Using Logical Pathnames}
\subsubsection{Logical Pathname Examples}
\subsection{Pathname Functions}
\section{File and Directory Operations}
\subsection{File I/O}
\begin{defun}{read-file-into-string}\end{defun}
\begin{defun}{rewind}\end{defun}
\subsubsection{Loading files}

\subsection{Renaming, Deleting, and Other FIle Operations}
\subsection{Accessing Directories}
\chapter{Errors}
\chapter{Advice}
\begin{defmacro}{defadvice} (\textit{function advice-name time} \&key \textit{where documentation}) (\textit{lambda-list}) \&body \textit{body}\end{defmacro}  
\chapter{Miscellaneous Features}
\section{The Compiler}
\begin{defun}{compile}\end{defun}
\begin{defun}{compile-file}\end{defun}
\begin{defvar}{*compile-verbose*}\end{defvar}
\begin{defvar}{*compile-print*}\end{defvar}
\begin{defvar}{*compile-file-pathname*}\end{defvar}
\begin{defvar}{*compile-file-truename*}\end{defvar}
\begin{special-form}{load-time-value}\end{special-form}
\begin{defun}{disassemble}\end{defun}
\begin{defun}{function-lambda-expression}\end{defun}
\begin{defmacro}{with-compilation-unit}\end{defmacro}
\subsection{Compiler Diagnostics}
\subsection{Compiled Functions}
\subsection{Compilation Environment}
\subsection{Similarity of Constants}
\section{Documentation} 
\begin{defgeneric}{documentation}\end{defgeneric}
\begin{defgeneric}{apropos}\end{defgeneric} %Hm. Should this be a generic function? this is EL::APROPOS, or CJ::APROPOS, not CL::APROPOS. I think it should return a list...
\section{Debugging Tools}
\begin{defmacro}{trace}\end{defmacro}
\begin{defmacro}{untrace}\end{defmacro}
\begin{defmacro}{step}\end{defmacro}
\begin{defmacro}{time}\end{defmacro}
\begin{defun}{describe}\end{defun}
\begin{defgeneric}{describe-object}\end{defgeneric}
\begin{defmethod}{describe-object}\end{defmethod}
\begin{defun}{inspect}\end{defun}
\begin{defun}{room}\end{defun}
\begin{defun}{ed}\end{defun}
\begin{defun}{dribble}\end{defun}
\section{Environment}

%% Read Erik Naggum's essay on time
Here there is significant influence from Erik Naggum's paper ``A Long, Painful History of Time ''\\
\begin{defclass}{$<$local-time$>$}{$<$standard-object$>$}\end{defclass}
\begin{defun}{make-local-time} \&key \textit{universal internal unix} (msec 0) (zone 0)\end{defun}
\begin{defun}{local-time-day}\end{defun}
\begin{defun}{local-time-sec}\end{defun}
\begin{defun}{local-time-msec}\end{defun}
\begin{defun}{local-time-zone}\end{defun}
\begin{defun}{local-time$<$}\end{defun}
\begin{defun}{local-time$<=$}\end{defun}
\begin{defun}{local-time$>$}\end{defun}
\begin{defun}{local-time$>=$}\end{defun}
\begin{defun}{local-time=}\end{defun}
\begin{defun}{local-time/=}\end{defun}
\begin{defun}{local-time-adjust} \textit{source timezone} \&optional \textit{destination}\\
\texttt{local-time-adjust} returns the values of the adjusted slots unless \textit{destination} is provided as a \texttt{local-time} instance, in which case it will first adjust the slots and then return the \textit{destination} \texttt{local-time} instance\end{defun}
\begin{defun}{get-local-time}\end{defun}
% The French Republican Calendar must be supported
\begin{defun}{get-french-time}\\
  This function returns the current time in the French Republican Calendar. The values it returns are: the year, the month, the day of the month, the hour, minute, and second. The current year is the number of years since the establishment of the calendar (in the Gregorian Calendar, 22 September 1792 C.E.; the New Year is thus set at 22 September in the \textsc{Koioslisp} implementation, though in actual usage it varied depending on the Autumn Equinox). The month is one of the following values: ``Vend\'{e}miaire'', ``Brumaire'', ``Frimaire'', ``Niv\^{o}se'', ``Pluvi\^{o}se'', ``Vent\^{o}se'', ``Germinal'', ``Flor\'{e}al'', ``Prairial'', ``Messidor'', ``Thermidor'', ``Fructidor'', or ``F\^{e}tes''; each month is 30 days long, except for the F\^{e}tes, which are 5 days long on normal years, 6 on leap years. A leap year occurs with the same rule as in the Gregorian calendar, but the origin date is the year 20.  \end{defun} %Move explanation of French Republican Calendar?
\begin{defun}{get-formatted-french-time} \&optional \textit{timestamp}\\
This function returns a formatted string representing the current French Republican Calendar time, or, if supplied a timestamp argument, formats the time represented by the timestamp. The format is specified as:\\
\textit{time} ::= \textlbrackdbl \textit{date-of-month} \textit{month} | \textit{f\^{e}te} \textrbrackdbl An \textit{year} de la R\'{e}volution, \textit{hour}:\textit{minute}:\textit{second}
\end{defun}
\begin{defun}{timestamp->french}\end{defun}
%
\begin{defun}{sleep} \textit{seconds}\end{defun}
\begin{defun}{syscall}\end{defun} %%Is it a function?
\begin{defun}{lisp-implementation-type}\\ Examples: ``Seattle Koioslisp'', ``Alonzo''. \end{defun}
\begin{defun}{lisp-implementation-version}\end{defun}
%%Should we keep machine-type?
\begin{defun}{os-type}\\ Returns a list of symbols which identify the operating system upon which Koioslisp runs--a list is chosen, of course, because some OSes implement a larger standard, or are part of a family that can be treated as a single unit. Some are provided here as standards for common systems:\\
\texttt{:gnu} The GNU system, often erroneously called Linux when paired with said kernel. Matches GNU/Linux systems, GNU/kFreeBSD systems, GNU/HURD systems, and any other GNU systems.\\
\texttt{:bsd} The BSD family of operating systems.\\
\texttt{:posix} The POSIX standard for operating systems.\\
\texttt{:loper} The Loper Operating System\\ %%Hm
\texttt{:plan-9} The Plan 9 Operating System\\
\texttt{:os-x} The Mac OS X operating system\\
\texttt{:windows} The Microsoft Windows operating system, and the React Operating System\\
\end{defun}
\begin{defun}{os-version}\end{defun}
\begin{defun}{software-type} %Other relevant support
\end{defun}
\begin{defvar}{*features*}\end{defvar}
\begin{defun}{identity} \textit{object} \end{defun}
\chapter{Pretty-Printing}
\chapter{Concurrency}
%% Erlang model
%% See also CL-MUPROC
%% How does one implement shared memory? make sure to look it up
\begin{defun}{spawn}\end{defun}
\begin{defmacro}{recieve}\end{defmacro} %% Can it be a fun.?
\begin{defother}{Recieve option}{after}\end{defother} % Timeout intervals
\begin{defun}{send}\end{defun} %% Can it be a fun.?
\\\begin{defun}{exit-proc}\end{defun} %% Perhaps not include?
\begin{defun}{spawn-remotely}\end{defun}
\begin{defun}{atomic}\end{defun} %You don't NEED to use atomic to setf (or maybe we should make an atomic-set! ?), but with threads, well...
\begin{defother}{Atomic anaphor}{retry}\end{defother}
\begin{defmacro}{or-else} \&rest \textit{args}\\
\end{defmacro}
\section{Refs}
A \textit{ref} is like a Concurrent Haskell \textit{TVar}; it is used for mutable shared state in concurrent programs.
\begin{defun}{ref}\end{defun}
\begin{defmacro}{defref}\\
\texttt{(defref x y)} is syntactic sugar for \texttt{(defvar x (ref y))} \end{defmacro}
\begin{defmacro}{getref}\end{defmacro} %Could it be a fun.?
\section{The Dining Philosophers Problem}
\begin{lisp}
%%%This is FAR from final and will DEFINETLY evolve based on how the STM system shapes up, but this is a good mock-up
%%%Revise for changes in how threads work
(def\= class $<$chopstick$>$ ()\\ 
\> ((owner :accessor chopstick-owner :initform (ref nil))))\\
(defvar *chopsticks*\\
\> '((make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)\\
\>   (make-instance '$<$chopstick$>$)))\\
(defclass $<$philosopher$>$ ($<$thread$>$)\\
\> ((name :accessor name-of :initarg name)\\
\> (meals-eaten :accessor phil-meals :initform (ref 0)) \\
\> (left :accessor phil-left :initarg left) \\
\> (right :accessor phil-right :initarg right)))\\
(defvar *philosophers*\\
\> '((make-instance '$<$philosopher$>$ :name ''Chomsky'' :left (nth *chopsticks* 0) :right (nth *chopsticks* 1))\\
\>  (make-instance '$<$philosopher$>$ :name ''Kongfuzi'' :left (nth *chopsticks* 1) :right (nth *chopsticks* 2))\\
\>  (make-instance '$<$philosopher$>$ :name ''Nietzsche'' :left (nth *chopsticks* 2) :right (nth *chopsticks* 3))\\ 
\>  (make-instance '$<$philosopher$>$ :name ''Marx'' :left (nth *chopsticks* 3) :right (nth *chopsticks* 4))\\
\>  (make-instance '$<$philosopher$>$ :name  ''Spinoza'' :left (nth *chopsticks* 4) :right (nth *chopsticks* 5))\\
\>  (make-instance '$<$philosopher$>$ :name ''Wittgenstein'' :left (nth *chopsticks* 5) :right (nth *chopsticks* 6))\\
\>  (make-instance '$<$philosopher$>$ :name ''de Beauvoir'' :left (nth *chopsticks* 6) :right (nth *chopsticks* 7))\\
\>  (make-instance '$<$philosopher$>$ :name  ''Dostoyevsky'' :left (nth *chopsticks* 7) :right (nth *chopsticks* 8))\\ 
\>  (make-instance '$<$philosopher$>$ :name ''de Saussure'' :left (nth *chopsticks* 8) :right (nth *chopsticks* 0)))\\
(defmethod run ((thread $<$philosopher$>$))\\
\> (un\= til (=? (phil-meals philosopher) 30)\\ %OK, this depends on how LOOP and such work...
\> \> (at\= omic \\
\> \> \> (if\=\ (not \\
\> \> \> \> (and \= (null? (chopstick-owner (phil-left philosopher))) \\
\> \> \> \> \> (null? (chopstick-owner (phil-right philosopher)))))\\
\> \> \> \> (retry)\\ %Come up with better name than this? also...atomically? hmm.
\> \> \> \> (begin\\
\> \> \> \> \> (set! (get-ref (chopstick-owner (phil-left philosopher))) (name-of philosopher))\\
\> \> \> \> \> (set! (get-ref (chopstick-owner (phil-right philosopher))) (name-of philosopher))\\
\> \> \> \> \> (format t ''\textasciitilde A has acquired two chopsticks''  (name-of philosopher)))))\\
\> \> (atomic\\
\> \> \> (inc (get-ref (phil-meals philosopher)))\\
\> \> \> (format t ''\textasciitilde A has eaten a tasty bite of rice'' (name-of philosopher))\\
\> \> \> (set! (get-ref (chopstick-owner (phil-left philosopher))) nil) \\
\> \> \> (set! (get-ref (chopstick-owner (phil-right philosopher))) nil)\\
\> \> \> (format t ''\textasciitilde A has returned to thinking'' (name-of philosopher))))\\
\> (format t ''\textasciitilde A has left the table'' (name-of philosopher)))\\
(mapc \#'spawn *philosophers*)
\end{lisp}
\chapter{Backquote} 
\chapter{Implementation Notes}
Some notes as to how to implement this are located here, however, the notes speak from a high-level, design perspective.{\sc Koioslisp}'s syntax and semantics have been designed in such a way that if one has a modern, working implementation of {\sc Common Lisp} (such as Steel Bank Common Lisp (SBCL)), one can adapt it with little effort to implement much of the {\sc Koioslisp} standard library. An interesting perspective on implementation, proposed by Richard P. Gabriel in his paper ``Lisp: Good News, Bad News, How to Win Big'', and followed by the experimental Lisp dialect Shen, is to create a kernel language small enough to implement easily, yet powerful enough to express the language--and implement the rest of the language as a standard library for the kernel (Shen's kernel language is called Kernel Lisp, or 'Kl', which, like Koioslisp, has used '.kl' as an extension. Koioslisp is not compatible with Kernel Lisp, and has no relation to it whatsoever). Another solution would be to implement it as an embedded language within Common Lisp. Whatever the solution turns out to be, we hope that these suggestions will prompt quicker implementation of {\sc Koioslisp}.
\chapter{Batteries--Utility Libraries}
Many of these ``batteries'' are connected to the outside world in such a way that if something were to drastically change, they would be obsoleted and will be updated. They are suggested, but not required, to be included in implementations of {\sc Koioslisp} as standard utility libraries--this is simply a description of a standard ``way'' to do the things described here. Some more complex utilities, such as a BitTorrent library, are not specified here as standard libraries but are encouraged to be developed by {\sc Koioslisp} users.
\section{Logging}
Standard logging levels include, from least to most severe, \texttt{+dribble+}, \texttt{+debug+}, \texttt{+info+}, \texttt{+warn+}, \texttt{+error+}, and \texttt{+fatal+}
\section{Data Compression}
\section{Foreign Function Interfaces}
\section{OS Services and Adaptations}
\subsection{UNIX-specific}
\section{Cryptography}
\section{Internet Data Handling}
\section{Markup Language Processing Tools}
\section{Internet Protocols}
\section{Multimedia Services}
\section{GUIs} %Perhaps replace with a KLIM chapter
\subsection{KLIM}
See the KLIM manual.
\subsection{Tk Interface}
\subsection{GTK+ Interface}
\subsection{Qt Interface}
\subsection{wxWidgets Interface}
\subsection{GNUstep Interface}
\chapter{Community Things}
These are (probably) not to be implemented as part of the language. Rather, they are services designed for the Koioslisp community. In fact, with some of them (such as Lake or LispDoc), there is encouraged to 
\section{CKLAN} 
{\sc cklan} is a proposed common repository for the hosting of useful software libre (FLOSS) {\sc Koioslisp} libraries, programs, and scripts. It is inspired by the {\sc cpan} (Comprehensive Perl Archive Network), which does the same for the Perl programming language.
\section{Lake}
Lake is the Koioslisp build language, similar to Unix make, Apache Ant, and Ruby Rake. It is also the interpreter for such a program
\section{LispDoc}
LispDoc generates documentation (in the form of \LaTeX or HTML) based on docstrings in a given selection of Koioslisp code. It is roughly similar to JavaDoc and RDoc in this respect.
\section{ASDF-like tools} 
\chapter{References} 
\end{document}
